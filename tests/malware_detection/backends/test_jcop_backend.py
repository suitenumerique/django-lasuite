"""Test JCop backend."""

from unittest import mock

import pytest
import requests
import responses
from django.core.files.base import ContentFile
from django.core.files.storage import default_storage

from lasuite.malware_detection import exceptions
from lasuite.malware_detection.backends import jcop
from lasuite.malware_detection.enums import ReportStatus
from lasuite.malware_detection.tasks.jcop import analyse_file_async, trigger_new_analysis

jcop_callback = mock.MagicMock()


@pytest.fixture(autouse=True)
def reset_jcop_callback():
    """Reset jcop_backend mock."""
    jcop_callback.reset_mock()


@pytest.fixture
def jcop_generate_file_path():
    """Create a file and return the path."""
    file_path = "file.txt"
    content_file = ContentFile("test")
    default_storage.save(file_path, content_file)
    yield file_path, "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08"
    default_storage.delete(file_path)


@pytest.fixture
def jcop_backend_parameters():
    """Return the parameters for the JCOP backend."""
    return {
        "base_url": "https://malware_detection.tld/api/v1",
        "api_key": "xxxx",
        "callback_path": "tests.malware_detection.backends.test_jcop_backend.jcop_callback",
    }


@pytest.fixture
def jcop_backend(jcop_backend_parameters):
    """Create a JCOP backend instance with test configuration."""
    return jcop.JCOPBackend(
        base_url="https://malware_detection.tld/api/v1",
        api_key="xxxx",
        callback_path="tests.malware_detection.backends.test_jcop_backend.jcop_callback",
    )


def test_jcop_backend_file_exists(jcop_generate_file_path, jcop_backend):
    """Test call the analyse_file_async when file exists."""
    with (
        mock.patch.object(analyse_file_async, "delay") as analyse_file_async_mock,
    ):
        file_path, _ = jcop_generate_file_path
        jcop_backend.analyse_file(file_path)
        analyse_file_async_mock.assert_called_once_with(
            "file.txt",
        )


def test_jcop_backend_file_exists_called_with_kwargs(jcop_generate_file_path, jcop_backend):
    """Test call the analyse_file_async with kwargs when file exists."""
    with (
        mock.patch.object(analyse_file_async, "delay") as analyse_file_async_mock,
    ):
        file_path, _ = jcop_generate_file_path
        jcop_backend.analyse_file(file_path, foo="bar")
        analyse_file_async_mock.assert_called_once_with(
            "file.txt",
            foo="bar",
        )


def test_jcop_backend_file_does_not_exists(jcop_backend):
    """Test call the backend file not existing must raise an exception."""
    with pytest.raises(FileNotFoundError):
        jcop_backend.analyse_file("file.txt")


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
@pytest.mark.parametrize("with_file_hash", [True, False])
def test_jcop_backend_analyse_file_async_done_no_malware(
    jcop_generate_file_path, jcop_backend, used_kwargs, with_file_hash
):
    """Test check_analysis with a safe file file."""
    file_path, file_hash = jcop_generate_file_path

    # Mock the results endpoint
    responses.add(
        responses.GET,
        f"https://malware_detection.tld/api/v1/results/{file_hash}",
        json={"done": True, "is_malware": False},
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=200,
    )

    should_retry = jcop_backend.check_analysis(
        file_path, file_hash=file_hash if with_file_hash else None, **used_kwargs
    )
    assert should_retry is False
    jcop_callback.assert_called_once_with("file.txt", ReportStatus.SAFE, error_info={}, **used_kwargs)


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
@pytest.mark.parametrize("with_file_hash", [True, False])
def test_jcop_backend_analyse_file_async_done_is_malware(
    jcop_generate_file_path, jcop_backend, used_kwargs, with_file_hash
):
    """Test check_analysis with an unsafe file."""
    file_path, file_hash = jcop_generate_file_path

    # Mock the results endpoint
    responses.add(
        responses.GET,
        f"https://malware_detection.tld/api/v1/results/{file_hash}",
        json={"done": True, "is_malware": True},
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=200,
    )

    should_retry = jcop_backend.check_analysis(
        file_path, file_hash=file_hash if with_file_hash else None, **used_kwargs
    )
    assert should_retry is False
    jcop_callback.assert_called_once_with(
        file_path,
        ReportStatus.UNSAFE,
        error_info={
            "error": "malware detected",
            "error_code": 5000,
        },
        **used_kwargs,
    )


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
@pytest.mark.parametrize("with_file_hash", [True, False])
@pytest.mark.parametrize("is_malware", [True, False])
def test_jcop_backend_analyse_file_async_done_with_error(  # noqa: PLR0913
    jcop_generate_file_path, jcop_backend, used_kwargs, with_file_hash, is_malware
):
    """Test check_analysis with errors in the response."""
    file_path, file_hash = jcop_generate_file_path

    # Mock the results endpoint
    responses.add(
        responses.GET,
        f"https://malware_detection.tld/api/v1/results/{file_hash}",
        json={"done": True, "is_malware": is_malware, "error": "error message", "error_code": 4001},
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=200,
    )

    should_retry = jcop_backend.check_analysis(
        file_path, file_hash=file_hash if with_file_hash else None, **used_kwargs
    )
    assert should_retry is False
    jcop_callback.assert_called_once_with(
        "file.txt",
        ReportStatus.UNSAFE if is_malware else ReportStatus.UNKNOWN,
        error_info={
            "error": "error message",
            "error_code": 4001,
        },
        **used_kwargs,
    )


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
@pytest.mark.parametrize("with_file_hash", [True, False])
def test_jcop_backend_analyse_file_async_not_done(jcop_generate_file_path, jcop_backend, used_kwargs, with_file_hash):
    """Test check_analysis with a not done analysis."""
    file_path, file_hash = jcop_generate_file_path

    # Mock the results endpoint
    responses.add(
        responses.GET,
        f"https://malware_detection.tld/api/v1/results/{file_hash}",
        json={"done": False},
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=200,
    )

    should_retry = jcop_backend.check_analysis(
        file_path, file_hash=file_hash if with_file_hash else None, **used_kwargs
    )
    assert should_retry is True
    jcop_callback.assert_not_called()


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
@pytest.mark.parametrize("with_file_hash", [True, False])
def test_jcop_backend_analyse_file_async_unauthorized_status_code(
    jcop_generate_file_path, jcop_backend, used_kwargs, with_file_hash
):
    """Test check_analysis api return an unauthorized status code."""
    file_path, file_hash = jcop_generate_file_path

    # Mock the results endpoint
    responses.add(
        responses.GET,
        f"https://malware_detection.tld/api/v1/results/{file_hash}",
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=401,
    )
    with pytest.raises(exceptions.MalwareDetectionInvalidAuthenticationError):
        jcop_backend.check_analysis(
            file_path,
            file_hash=file_hash if with_file_hash else None,
            **used_kwargs,
        )

    jcop_callback.assert_called_once_with(
        file_path,
        ReportStatus.UNKNOWN,
        error_info={
            "error": "Invalid API key",
            "error_code": 401,
        },
        **used_kwargs,
    )


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
@pytest.mark.parametrize("with_file_hash", [True, False])
def test_jcop_backend_analyse_file_async_no_treatment(
    jcop_generate_file_path, jcop_backend, used_kwargs, with_file_hash
):
    """Test when there is no suitable case for check_analysis method."""
    file_path, file_hash = jcop_generate_file_path

    # Mock the results endpoint
    responses.add(
        responses.GET,
        f"https://malware_detection.tld/api/v1/results/{file_hash}",
        json={"done": True},
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=200,
    )

    should_retry = jcop_backend.check_analysis(
        file_path, file_hash=file_hash if with_file_hash else None, **used_kwargs
    )
    assert should_retry is False
    jcop_callback.assert_called_once_with(
        file_path,
        ReportStatus.UNKNOWN,
        error_info={
            "error": "Unknown treatment",
            "error_code": 200,
        },
        **used_kwargs,
    )


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
@pytest.mark.parametrize("with_file_hash", [True, False])
def test_jcop_backend_analyse_file_async_request_error(
    jcop_generate_file_path, jcop_backend, used_kwargs, with_file_hash
):
    """Test with a request exception should raise a Request exception."""
    file_path, file_hash = jcop_generate_file_path

    # Mock the results endpoint
    responses.add(
        responses.GET,
        f"https://malware_detection.tld/api/v1/results/{file_hash}",
        body=requests.exceptions.RequestException(),
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=200,
    )
    with pytest.raises(requests.exceptions.RequestException):
        jcop_backend.check_analysis(file_path, file_hash=file_hash if with_file_hash else None, **used_kwargs)

    jcop_callback.assert_not_called()


# @responses.activate
# @pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
# @pytest.mark.parametrize("with_file_hash", [True, False])
# def test_jcop_backend_analyse_file_async_request_error_max_retry(
#     jcop_generate_file_path, jcop_backend_parameters, used_kwargs, with_file_hash
# ):
#     """Test with a request exception should raise a Retry exception."""
#     file_path, file_hash = jcop_generate_file_path

#     # Mock the results endpoint
#     responses.add(
#         responses.GET,
#         f"https://malware_detection.tld/api/v1/results/{file_hash}",
#         body=requests.exceptions.RequestException(),
#         headers={
#             "X-Auth-Token": "xxxx",
#             "Accept": "application/json",
#         },
#         status=200,
#     )
#     with mock.patch.object(analyse_file_async, "retry"):
#         analyse_file_async.max_retries = 0
#         analyse_file_async(
#             file_path,
#             file_hash=file_hash if with_file_hash else None,
#             **jcop_backend_parameters,
#             **used_kwargs,
#         )

#     jcop_callback.assert_called_once_with(
#         file_path,
#         ReportStatus.UNKNOWN,
#         error_info={
#             "error": "Max retries fetching results exceeded",
#             "error_code": 5000,
#         },
#         **used_kwargs,
#     )


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
@pytest.mark.parametrize("with_file_hash", [True, False])
def test_jcop_backend_analyse_file_async_no_existing_result(
    jcop_generate_file_path, jcop_backend, used_kwargs, with_file_hash
):
    """Test when no result found should start the trigger_new_analysis task."""
    file_path, file_hash = jcop_generate_file_path

    # Mock the results endpoint
    responses.add(
        responses.GET,
        f"https://malware_detection.tld/api/v1/results/{file_hash}",
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=404,
    )
    with mock.patch.object(trigger_new_analysis, "delay") as mock_trigger_new_analysis:
        should_retry = jcop_backend.check_analysis(
            file_path, file_hash=file_hash if with_file_hash else None, **used_kwargs
        )
        assert should_retry is False

        mock_trigger_new_analysis.assert_called_once_with(
            file_path,
            **used_kwargs,
        )


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
def test_jcop_backend_trigger_new_analysis_success(jcop_generate_file_path, jcop_backend, used_kwargs):
    """Test successful submission of a file for analysis."""
    file_path, file_hash = jcop_generate_file_path

    # Mock the submit endpoint
    responses.add(
        responses.POST,
        "https://malware_detection.tld/api/v1/submit",
        json={"id": file_hash},
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=200,
    )

    with mock.patch.object(analyse_file_async, "apply_async") as mock_apply_async:
        jcop_backend.trigger_new_analysis(file_path, **used_kwargs)
        mock_apply_async.assert_called_once_with(
            countdown=30,
            args=(file_path,),
            kwargs={
                "file_hash": file_hash,
                **used_kwargs,
            },
        )


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
def test_jcop_backend_trigger_new_analysis_unauthorized(jcop_generate_file_path, jcop_backend, used_kwargs):
    """Test submission with invalid API key."""
    file_path, _ = jcop_generate_file_path

    # Mock the submit endpoint
    responses.add(
        responses.POST,
        "https://malware_detection.tld/api/v1/submit",
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=401,
    )

    with pytest.raises(exceptions.MalwareDetectionInvalidAuthenticationError):
        jcop_backend.trigger_new_analysis(file_path, **used_kwargs)

    jcop_callback.assert_called_once_with(
        file_path,
        ReportStatus.UNKNOWN,
        error_info={
            "error": "Invalid API key",
            "error_code": 401,
        },
        **used_kwargs,
    )


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
def test_jcop_backend_trigger_new_analysis_timeout_max_retries(jcop_generate_file_path, jcop_backend, used_kwargs):
    """Test submission with timeout after max retries."""
    file_path, _ = jcop_generate_file_path

    # Mock the submit endpoint
    responses.add(
        responses.POST,
        "https://malware_detection.tld/api/v1/submit",
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=408,
    )

    with pytest.raises(TimeoutError):
        jcop_backend.trigger_new_analysis(file_path, **used_kwargs)

    jcop_callback.assert_not_called()


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
def test_jcop_backend_trigger_new_analysis_file_too_large(jcop_generate_file_path, jcop_backend, used_kwargs):
    """Test submission with file too large."""
    file_path, _ = jcop_generate_file_path

    # Mock the submit endpoint
    responses.add(
        responses.POST,
        "https://malware_detection.tld/api/v1/submit",
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=413,
    )

    jcop_backend.trigger_new_analysis(file_path, **used_kwargs)

    jcop_callback.assert_called_once_with(
        file_path,
        ReportStatus.UNKNOWN,
        error_info={
            "error": "File too large",
            "error_code": 413,
        },
        **used_kwargs,
    )


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
def test_jcop_backend_trigger_new_analysis_request_error(jcop_generate_file_path, jcop_backend, used_kwargs):
    """Test submission with request error."""
    file_path, _ = jcop_generate_file_path

    # Mock the submit endpoint
    responses.add(
        responses.POST,
        "https://malware_detection.tld/api/v1/submit",
        body=requests.exceptions.RequestException(),
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=200,
    )
    with pytest.raises(requests.exceptions.RequestException):
        jcop_backend.trigger_new_analysis(file_path, **used_kwargs)

    jcop_callback.assert_not_called()


@responses.activate
@pytest.mark.parametrize("used_kwargs", [{}, {"foo": "bar"}])
def test_jcop_backend_trigger_new_analysis_unknown_status(jcop_generate_file_path, jcop_backend, used_kwargs):
    """Test submission with unknown status code."""
    file_path, _ = jcop_generate_file_path

    # Mock the submit endpoint
    responses.add(
        responses.POST,
        "https://malware_detection.tld/api/v1/submit",
        headers={
            "X-Auth-Token": "xxxx",
            "Accept": "application/json",
        },
        status=500,
    )

    jcop_backend.trigger_new_analysis(file_path, **used_kwargs)

    jcop_callback.assert_called_once_with(
        file_path,
        ReportStatus.UNKNOWN,
        error_info={
            "error": "Unknown treatment",
            "error_code": 500,
        },
        **used_kwargs,
    )
