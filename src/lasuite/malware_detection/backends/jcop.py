"""Module contains the JCOP backends for the malware detection system."""

import hashlib
import logging
from http import HTTPStatus

import requests
from celery import shared_task
from django.core.files.storage import default_storage
from django.utils.module_loading import import_string
from requests_toolbelt.multipart.encoder import MultipartEncoder

from ..enums import ReportStatus
from ..exceptions import MalwareDetectionInvalidAuthenticationError
from .base import BaseBackend

logger = logging.getLogger(__name__)


class JCOPBackend(BaseBackend):
    """A backend that uses JCOP to detect malware."""

    def __init__(
        self, base_url: str, api_key: str, callback_path: str, result_timeout: int = 30, submit_timeout: int = 10 * 60
    ):
        """Configure the JCOP backend."""
        self.base_url = base_url
        self.api_key = api_key
        self.callback_path = callback_path
        self.result_timeout = result_timeout
        self.submit_timeout = submit_timeout

    def analyse_file(self, file_path: str, **kwargs) -> None:
        """Trigger a process to analyse a file using JCOP service."""
        if not default_storage.exists(file_path):
            raise FileNotFoundError(f"File {file_path} not found")

        analyse_file_async.delay(
            file_path,
            api_key=self.api_key,
            base_url=self.base_url,
            callback_path=self.callback_path,
            result_timeout=self.result_timeout,
            submit_timeout=self.submit_timeout,
            **kwargs,
        )


@shared_task(
    bind=True,
    default_retry_delay=30,
    max_retries=10,
    dont_autoretry_for=(MalwareDetectionInvalidAuthenticationError,),
)
def analyse_file_async(  # noqa: PLR0913
    self,
    file_path: str,
    api_key: str,
    base_url: str,
    callback_path: str,
    result_timeout: int = 30,
    submit_timeout: int = 60 * 10,
    file_hash: str | None = None,
    **kwargs,
) -> None:
    """Task starting analysis process for a file."""
    if not file_hash:
        with default_storage.open(file_path, "rb") as file:
            file_hash = hashlib.file_digest(file, "sha256").hexdigest()

    callback = import_string(callback_path)

    try:
        # try if the file as already been tested
        response = requests.get(
            f"{base_url}/results/{file_hash}",
            headers={
                "X-Auth-Token": api_key,
                "Accept": "application/json",
            },
            timeout=result_timeout,
        )
    except requests.exceptions.RequestException as exc:
        logger.error("Error getting cache result for file %s: %s", file_path, exc)
        if self.request.retries >= self.max_retries:
            callback(
                file_path,
                ReportStatus.UNKNOWN,
                error_info={
                    "error": "Max retries fetching results exceeded",
                    "error_code": 5000,
                },
                **kwargs,
            )
        self.retry(exc=exc)
        return

    if response.status_code == HTTPStatus.NOT_FOUND:
        # start a new analysis
        trigger_new_analysis.delay(
            file_path,
            api_key=api_key,
            base_url=base_url,
            callback_path=callback_path,
            result_timeout=result_timeout,
            submit_timeout=submit_timeout,
            **kwargs,
        )
        return

    if response.status_code == HTTPStatus.UNAUTHORIZED:
        callback(
            file_path,
            ReportStatus.UNKNOWN,
            error_info={
                "error": "Invalid API key",
                "error_code": response.status_code,
            },
            **kwargs,
        )
        raise MalwareDetectionInvalidAuthenticationError()

    if response.status_code == HTTPStatus.OK:
        content = response.json()
        if content.get("done") is False:
            # the analysis is not done yet, retry later
            self.retry()
            return

        if content.get("error_code"):
            status = ReportStatus.UNSAFE if content["is_malware"] else ReportStatus.UNKNOWN
            callback(
                file_path,
                status,
                error_info={
                    "error": content["error"],
                    "error_code": content["error_code"],
                },
                **kwargs,
            )
            return

        if content.get("is_malware") is False:
            callback(file_path, ReportStatus.SAFE, error_info={}, **kwargs)
            return

    # Any other case, call the callback with an unknown error
    callback(
        file_path,
        ReportStatus.UNKNOWN,
        error_info={
            "error": "Unknown treatment",
            "error_code": response.status_code,
        },
        **kwargs,
    )


@shared_task(bind=True, max_retries=6, dont_autoretry_for=(MalwareDetectionInvalidAuthenticationError,))
def trigger_new_analysis(  # noqa: PLR0913
    self,
    file_path: str,
    api_key: str,
    base_url: str,
    callback_path: str,
    result_timeout: int = 30,
    submit_timeout: int = 10 * 60,
    **kwargs,
) -> None:
    """Trigger a new analysis for a file."""
    with default_storage.open(file_path, "rb") as file:
        callback = import_string(callback_path)

        encoder = MultipartEncoder(
            fields={
                "file": (file.name, file),
            }
        )
        try:
            response = requests.post(
                f"{base_url}/submit",
                headers={
                    "X-Auth-Token": api_key,
                    "Accept": "application/json",
                    "Content-Type": encoder.content_type,
                },
                data=encoder,
                timeout=(30, submit_timeout),
            )
        except requests.exceptions.RequestException as exc:
            logger.error("Error submitting file to JCOP: %s", exc)
            if self.request.retries >= self.max_retries:
                callback(
                    file_path,
                    ReportStatus.UNKNOWN,
                    error_info={
                        "error": "Max retries triggering new analysis exceeded",
                        "error_code": 5000,
                    },
                    **kwargs,
                )
            self.retry(exc=exc)
            return

    if response.status_code == HTTPStatus.OK:
        content = response.json()
        analyse_file_async.apply_async(
            countdown=30,
            args=(file_path,),
            kwargs={
                "file_hash": content["id"],
                "api_key": api_key,
                "base_url": base_url,
                "callback_path": callback_path,
                "result_timeout": result_timeout,
                "submit_timeout": submit_timeout,
                **kwargs,
            },
        )
        return

    if response.status_code == HTTPStatus.UNAUTHORIZED:
        callback(
            file_path,
            ReportStatus.UNKNOWN,
            error_info={
                "error": "Invalid API key",
                "error_code": response.status_code,
            },
            **kwargs,
        )
        raise MalwareDetectionInvalidAuthenticationError()

    if response.status_code == HTTPStatus.REQUEST_TIMEOUT:
        if self.request.retries >= self.max_retries:
            callback(
                file_path,
                ReportStatus.UNKNOWN,
                error_info={
                    "error": "Max retries triggering new analysis exceeded",
                    "error_code": 5000,
                },
                **kwargs,
            )
        self.retry(exc=TimeoutError())
        return

    if response.status_code == HTTPStatus.REQUEST_ENTITY_TOO_LARGE:
        callback(
            file_path,
            ReportStatus.UNKNOWN,
            error_info={
                "error": "File too large",
                "error_code": response.status_code,
            },
            **kwargs,
        )
        return

    callback(
        file_path,
        ReportStatus.UNKNOWN,
        error_info={
            "error": "Unknown treatment",
            "error_code": response.status_code,
        },
        **kwargs,
    )
