"""Module contains the JCOP backends for the malware detection system."""

import hashlib
import logging
from http import HTTPStatus

import requests
from django.core.files.storage import default_storage
from requests_toolbelt import MultipartEncoder

from ..enums import ReportStatus
from ..exceptions import MalwareDetectionInvalidAuthenticationError
from ..tasks.jcop import analyse_file_async, trigger_new_analysis
from .base import BaseBackend

logger = logging.getLogger(__name__)


class JCOPBackend(BaseBackend):
    """A backend that uses JCOP to detect malware."""

    def __init__(
        self, base_url: str, api_key: str, callback_path: str, result_timeout: int = 30, submit_timeout: int = 10 * 60
    ):
        """Configure the JCOP backend."""
        self.base_url = base_url
        self.api_key = api_key
        self.callback_path = callback_path
        self.result_timeout = result_timeout
        self.submit_timeout = submit_timeout

    def analyse_file(self, file_path: str, **kwargs) -> None:
        """Trigger a process to analyse a file using JCOP service."""
        if not default_storage.exists(file_path):
            raise FileNotFoundError(f"File {file_path} not found")

        analyse_file_async.delay(
            file_path,
            **kwargs,
        )

    def failed_analysis(
        self, file_path: str, error_code: int, error_msg: str, status: ReportStatus | None = None, **kwargs
    ) -> None:
        """Handle a failed analysis."""
        self.callback(
            file_path,
            status if status is not None else ReportStatus.UNKNOWN,
            error_info={
                "error": error_msg,
                "error_code": error_code,
            },
            **kwargs,
        )

    def succeed_analysis(self, file_path: str, **kwargs) -> None:
        """Handle a successful analysis."""
        self.callback(file_path, ReportStatus.SAFE, error_info={}, **kwargs)

    def check_analysis(self, file_path: str, file_hash: str | None = None, **kwargs) -> bool:
        """Start the analysis process for a file."""
        if file_hash is None:
            with default_storage.open(file_path, "rb") as file:
                file_hash = hashlib.file_digest(file, "sha256").hexdigest()

        try:
            # try if the file as already been tested
            response = requests.get(
                f"{self.base_url}/results/{file_hash}",
                headers={
                    "X-Auth-Token": self.api_key,
                    "Accept": "application/json",
                },
                timeout=self.result_timeout,
            )
        except requests.exceptions.RequestException as exc:
            logger.error("Error getting cache result for file %s: %s", file_path, exc)
            raise

        if response.status_code == HTTPStatus.NOT_FOUND:
            # start a new analysis
            trigger_new_analysis.delay(
                file_path,
                **kwargs,
            )
            return False

        if response.status_code == HTTPStatus.UNAUTHORIZED:
            self.failed_analysis(
                file_path, response.status_code, "Invalid API key", status=ReportStatus.UNKNOWN, **kwargs
            )
            raise MalwareDetectionInvalidAuthenticationError()

        if response.status_code == HTTPStatus.OK:
            content = response.json()
            if content.get("done", False) is False:
                # the analysis is not done yet, retry later
                return True

            is_malware = content.get("is_malware")
            if is_malware is True or content.get("error_code"):
                status = ReportStatus.UNSAFE if is_malware else ReportStatus.UNKNOWN
                self.failed_analysis(
                    file_path,
                    content.get("error_code", 5000),
                    content.get("error", "malware detected"),
                    status,
                    **kwargs,
                )
                return False

            if is_malware is False:
                self.succeed_analysis(file_path, **kwargs)
                return False

        # Any other case, call the callback with an unknown error
        self.failed_analysis(
            file_path, response.status_code, "Unknown treatment", status=ReportStatus.UNKNOWN, **kwargs
        )
        return False

    def trigger_new_analysis(self, file_path: str, **kwargs):
        """Trigger a new analysis for a file."""
        with default_storage.open(file_path, "rb") as file:
            encoder = MultipartEncoder(
                fields={
                    "file": (file.name, file),
                }
            )
            try:
                response = requests.post(
                    f"{self.base_url}/submit",
                    headers={
                        "X-Auth-Token": self.api_key,
                        "Accept": "application/json",
                        "Content-Type": encoder.content_type,
                    },
                    data=encoder,
                    timeout=(30, self.submit_timeout),
                )
            except requests.exceptions.RequestException as exc:
                logger.error("Error submitting file to JCOP: %s", exc)
                raise

        if response.status_code == HTTPStatus.OK:
            content = response.json()
            analyse_file_async.apply_async(
                countdown=30,
                args=(file_path,),
                kwargs={"file_hash": content["id"], **kwargs},
            )
            return

        if response.status_code == HTTPStatus.UNAUTHORIZED:
            self.failed_analysis(
                file_path, response.status_code, "Invalid API key", status=ReportStatus.UNKNOWN, **kwargs
            )
            raise MalwareDetectionInvalidAuthenticationError()

        if response.status_code == HTTPStatus.REQUEST_TIMEOUT:
            raise TimeoutError()

        if response.status_code == HTTPStatus.REQUEST_ENTITY_TOO_LARGE:
            self.failed_analysis(
                file_path, response.status_code, "File too large", status=ReportStatus.UNKNOWN, **kwargs
            )
            return

        self.failed_analysis(
            file_path, response.status_code, "Unknown treatment", status=ReportStatus.UNKNOWN, **kwargs
        )
